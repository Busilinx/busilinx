<?php

/**
 * @file
 *   Form settings per user
 *
 * @version
 *   $Id: nodeaccess_autoreference.module,v 1.1.2.5 2009/07/16 15:30:59 kenorb Exp $
 *
 * @developers:
 *   Rafal Wieczorek <kenorb@gmail.com>
 *   Konrad Wieczorek <kw.keth@gmail.com>
 */

/**
 * Implementation of hook_menu().
 */
function nodeaccess_autoreference_menu() { 
  $items['admin/settings/nodeaccess_autoreference'] = array(
    'title' => t('Node Access Auto Reference Settings'),
    'description' => t('Settings page for Auto References.'),
    'page callback' => 'drupal_get_form', 
    'page arguments' => array('nodeaccess_autoreference_admin_form'),
    'access arguments' => array('administer autoreference settings'),
    'file' => 'nodeaccess_autoreference.admin.inc', 
  );

  return $items;
}

/**
 * Implementation of hook_node_grants
 *
 */
function nodeaccess_autoreference_node_grants($account, $op) {
  return array(
    'nodeaccess_autoreference_owner' => array($account->uid),
  );
}

/**
 * Implementation of hook_perm().
 *
 * Add edit and delete permissions for all content types through references
 */

function nodeaccess_autoreference_perm() {
  foreach (node_get_types() as $type) {
    $perms[] = 'edit referenced '. $type->type .' content';
    $perms[] = 'delete referenced '. $type->type .' content';
  }
  $perms[] = 'administer autoreference settings';
  return $perms;
}

/**
 * Implementation of hook_nodeapi().
 */
function nodeaccess_autoreference_nodeapi(&$node, $op) {
  if ($op == 'load') {
    global $na_skip_next_load;
    if (isset($na_skip_next_load)) {
      unset($na_skip_next_load);
      return;
    }

    global $user;
    $grants = module_invoke_all('node_grants', $user, 'view');

    if (!node_access('view', $node)
      || (!node_access('update', $node) && user_access("edit referenced $node->type content"))
      || (!node_access('delete', $node) && user_access("delete referenced $node->type content")))
    {
      module_load_include('inc', 'nodeaccess_autoreference'); // load additional function from included file
      if (!variable_get('nodeaccess_autoreference_disable', FALSE) && $grants = nodeaccess_autoreference_node_get_grants($node)) {
        node_access_write_grants($node, $grants);
        if (variable_get('nodeaccess_autoreference_log', FALSE)) {
          $args = array('%nid' => $node->nid, '%permission' => print_r($grants, TRUE));
          $msg = 'Added permissions to node %nid. (permission: %permission)';
        }
      } else {
          $args = array('%nid' => $node->nid, '%permission' => print_r($grants, TRUE), '%option' => 'nodeaccess_autoreference_disable');
          $msg = 'Option: %option disabled! Not added permissions to node %nid. (permission: %permission)';
      }
      watchdog('permission', $msg, $args, WATCHDOG_INFO);
      if (variable_get('nodeaccess_autoreference_debug', FALSE) && user_access('administer autoreference settings')) {
        drupal_set_message(t($msg, $args), 'status');
      }
    }
    if (variable_get('nodeaccess_autoreference_debug', FALSE)) {
      module_load_include('inc', 'nodeaccess_autoreference'); // load additional function from included file
      $connected = empty($connected) ? nodeaccess_autoreference_obj_connected(array('nid', $node), $user, $path) : $connected;
      drupal_set_message(t('Connected: %connected; Path between user %uid and node %nid: %path', array('%nid' => $node->nid, '%uid' => $user->uid, '%path' => !empty($path) ? print_r($path,true) : t('n/a'), '%connected' => ($connected ? 'YES' : 'NO'))), 'status');
    }
  }
} 

/**
 * Implementation of hook_node_access_records().
 */
function nodeaccess_autoreference_node_access_records($node) {
  if (variable_get('nodeaccess_autoreference_disable', FALSE)) {
    return;
  }
  module_load_include('inc', 'nodeaccess_autoreference'); // load additional function from included file
  return nodeaccess_autoreference_node_get_grants($node);
}
 
